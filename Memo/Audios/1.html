<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Áudio estilo WhatsApp + imagem</title>

  <!-- Font Awesome (para o microfone) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

  <style>
    :root{
      --bubble-bg: rgba(18,140,126,0.06); /* transparente por padrão para encaixar no seu layout */
      --primary: #25D366; /* cor do play */
      --active-bar: #ffffff;
      --inactive-bar: rgba(255,255,255,0.35);
      --wave-height: 30px;
      --bar-width: 4px;
      --bars-gap: 3px;
    }

    html,body{height:100%;margin:0;padding:0;background:transparent;font-family:Arial,Helvetica,sans-serif;}

    /* container que você incorpora no Typebot */
    .audio-container{
      display:flex;
      align-items:center;
      gap:12px;
      width:100%;
      box-sizing:border-box;
      padding:8px;
      cursor:pointer;
      user-select:none;
      -webkit-user-select:none;
    }

    /* botão play circular */
    .play-btn{
      width:44px;
      height:44px;
      border-radius:50%;
      border:0;
      background:var(--primary);
      color:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      box-shadow:0 2px 0 rgba(0,0,0,0.08);
      flex:0 0 44px;
    }

    /* waveform (estilo whatsapp) */
    .waveform{
      flex:1 1 auto;
      display:flex;
      align-items:flex-end;
      gap: var(--bars-gap);
      height: var(--wave-height);
      min-width: 40px;
      box-sizing:border-box;
      padding-right:6px;
    }

    .bar{
      width: var(--bar-width);
      height: 8px;
      border-radius: 3px;
      background: var(--inactive-bar);
      transition: height 0.08s linear, background 0.12s linear;
      align-self:flex-end;
      transform-origin: center bottom;
    }

    /* avatar + ícone de microfone sobreposto (mantive sua estética) */
    .avatar-wrap{
      position:relative;
      width:50px;
      height:50px;
      flex:0 0 50px;
    }

    .avatar-wrap img{
      width:100%;
      height:100%;
      object-fit:cover;
      border-radius:50%;
      display:block;
    }

    .microphone-icon{
      position:absolute;
      right: -8px; /* sobreposição leve */
      bottom: -8px;
      font-size:20px;
      color:#4ad954;
      background:transparent;
      z-index:3;
      pointer-events:none;
      text-shadow: 0 1px 0 rgba(0,0,0,0.12);
    }

    .microphone-icon.blue{ color:#3db8ee; }

    /* esconder controles nativos (se houver) */
    audio { display:none; }
  </style>
</head>
<body>
  <div class="audio-container" id="audioContainer">
    <button class="play-btn" id="playBtn" aria-label="Play/Pause">▶</button>

    <div class="waveform" id="waveform" aria-hidden="true"></div>

    <div class="avatar-wrap">
      <img id="avatar" src="https://storage.chatecom.app/typebot/public/workspaces/gabrielpiochtavares@gmail.com/typebots/9af33e3d8b4d48209446784c81e9b566/blocks/cuae0wqlihuenlo77xtay29d?v=1726604919248" alt="Imagem">
      <div class="microphone-icon" id="micIcon"><i class="fas fa-microphone"></i></div>
    </div>

    <!-- seu áudio (mantive a mesma URL) -->
    <audio id="audio" crossorigin="anonymous"
      src="https://s3.typebot.io/public/workspaces/cmfid3w9w000qjr04ulcjbft9/typebots/b09hepl041fyv7q5nhf6dt39/blocks/uqehab3o02f69iybmix0wvrs?v=1757669692226"></audio>
  </div>

  <script>
    (function(){
      const audio = document.getElementById('audio');
      const playBtn = document.getElementById('playBtn');
      const waveform = document.getElementById('waveform');
      const micIcon = document.getElementById('micIcon');
      const audioContainer = document.getElementById('audioContainer');

      const NUM_BARS = 18; // quantas barrinhas (ajuste se quiser)
      const MAX_BAR_HEIGHT = 30; // px (altura máxima da barra)
      const ACTIVE_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--active-bar').trim() || '#fff';
      const INACTIVE_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--inactive-bar').trim() || 'rgba(255,255,255,0.35)';

      // cria as barras
      const bars = [];
      for (let i=0;i<NUM_BARS;i++){
        const b = document.createElement('div');
        b.classList.add('bar');
        // altura inicial aleatória para parecer natural
        b.style.height = (6 + Math.round(Math.random()* (MAX_BAR_HEIGHT - 6))) + 'px';
        b.style.background = INACTIVE_COLOR;
        waveform.appendChild(b);
        bars.push(b);
      }

      // Web Audio API setup
      let audioCtx = null, analyser = null, sourceNode = null;
      let dataArray = null, bufferLength = 0;
      let rafId = null;
      let analyserAvailable = false;

      function setupAnalyser(){
        try {
          if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            sourceNode = audioCtx.createMediaElementSource(audio);
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256; // mais leve; ajuste para mais/menos resolução
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            sourceNode.connect(analyser);
            analyser.connect(audioCtx.destination);
            analyserAvailable = true;
          }
        } catch(e) {
          analyserAvailable = false;
          console.warn('Analyser não disponível (CORS ou navegador). Usando fallback estático.', e);
        }
      }

      function updateWithAnalyser(){
        if (!analyser) return;
        analyser.getByteFrequencyData(dataArray);

        // dividir o espectro em NUM_BARS fatias
        for (let i=0;i<NUM_BARS;i++){
          const start = Math.floor(i * bufferLength / NUM_BARS);
          const end = Math.floor((i+1) * bufferLength / NUM_BARS);
          let sum = 0;
          for (let j=start; j<=end; j++) sum += dataArray[j];
          const avg = sum / (end - start + 1);
          // mapear avg (0-255) para altura (4 - MAX_BAR_HEIGHT)
          const h = Math.max(4, Math.round((avg/255) * MAX_BAR_HEIGHT));
          bars[i].style.height = h + 'px';
        }

        // colorir a parte já tocada (progresso)
        const prog = (audio.duration && !isNaN(audio.duration)) ? (audio.currentTime / audio.duration) : 0;
        const playedIndex = Math.floor(prog * NUM_BARS);
        bars.forEach((bar, idx) => {
          bar.style.background = (idx <= playedIndex) ? ACTIVE_COLOR : INACTIVE_COLOR;
        });

        rafId = requestAnimationFrame(updateWithAnalyser);
      }

      // fallback (se Analyser não disponível) — simula movimento leve e colore por progresso
      let fallbackInterval = null;
      function startFallbackAnimation(){
        clearInterval(fallbackInterval);
        fallbackInterval = setInterval(()=>{
          // pequenas variações de altura
          bars.forEach(b=>{
            const h = 6 + Math.round(Math.random() * (MAX_BAR_HEIGHT - 6));
            b.style.height = h + 'px';
          });
          // colorir por progresso
          const prog = (audio.duration && !isNaN(audio.duration)) ? (audio.currentTime / audio.duration) : 0;
          const playedIndex = Math.floor(prog * NUM_BARS);
          bars.forEach((bar, idx) => {
            bar.style.background = (idx <= playedIndex) ? ACTIVE_COLOR : INACTIVE_COLOR;
          });
        }, 120);
      }

      function stopFallbackAnimation(){
        clearInterval(fallbackInterval);
      }

      function startVisuals(){
        // muda cor do mic
        micIcon.classList.add('blue');

        // tenta o analyser
        setupAnalyser();
        if (analyserAvailable){
          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(updateWithAnalyser);
        } else {
          startFallbackAnimation();
        }
      }

      function stopVisuals(){
        micIcon.classList.remove('blue');
        if (rafId) cancelAnimationFrame(rafId);
        stopFallbackAnimation();
      }

      // play/pause handlers
      async function playAudio(){
        try {
          // necessário retomar o contexto em alguns navegadores
          if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
          await audio.play();
          playBtn.textContent = '⏸';
          startVisuals();
        } catch(e){
          console.warn('Erro ao tocar o áudio:', e);
        }
      }

      function pauseAudio(){
        audio.pause();
        playBtn.textContent = '▶';
        stopVisuals();
      }

      playBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        if (audio.paused) playAudio();
        else pauseAudio();
      });

      // clique no container (fora dos controles) também alterna
      audioContainer.addEventListener('click', (e)=>{
        // se clicou no próprio botão, já foi tratado
        if (e.target === playBtn) return;
        if (audio.paused) playAudio();
        else pauseAudio();
      });

      // eventos do elemento audio
      audio.addEventListener('ended', ()=>{
        playBtn.textContent = '▶';
        stopVisuals();
        // reset visual para estado inicial
        bars.forEach(b=>{
          b.style.height = (6 + Math.round(Math.random()* (MAX_BAR_HEIGHT - 6))) + 'px';
          b.style.background = INACTIVE_COLOR;
        });
      });

      audio.addEventListener('pause', ()=>{
        playBtn.textContent = '▶';
        stopVisuals();
      });

      audio.addEventListener('play', async ()=>{
        // garantir que o contexto seja criado/resumido após a interação do usuário
        if (!audioCtx) setupAnalyser();
        if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
        startVisuals();
      });

      // atualização de progresso para colorir barras também quando o usuário seekar
      audio.addEventListener('timeupdate', ()=>{
        if (!analyserAvailable){
          // mesmo em fallback, já temos interval que colorirá, mas aqui garantimos cor imediata
          const prog = (audio.duration && !isNaN(audio.duration)) ? (audio.currentTime / audio.duration) : 0;
          const playedIndex = Math.floor(prog * NUM_BARS);
          bars.forEach((bar, idx) => {
            bar.style.background = (idx <= playedIndex) ? ACTIVE_COLOR : INACTIVE_COLOR;
          });
        }
      });

      // segurança: se o Analyser lançar, usamos fallback
      window.addEventListener('unhandledrejection', ()=>{ analyserAvailable=false; });

      // opcional: pre-config para cross origin (já está no elemento audio via atributo)
    })();
  </script>
</body>
</html>
