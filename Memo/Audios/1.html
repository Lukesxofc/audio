<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>Áudio estilo WhatsApp - integrado com avatar</title>

  <!-- Font Awesome apenas para o ícone do microfone -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

  <style>
    :root{
      --bg: transparent;
      --primary: #25D366;          /* play button */
      --bar-active: #ffffff;      /* cor das barras já tocadas */
      --bar-inactive: rgba(255,255,255,0.35); /* cor das barras não tocadas */
    }

    html,body{height:100%;margin:0;padding:0;background:var(--bg);font-family:Inter,Arial,Helvetica,sans-serif;}

    /* wrapper específico para evitar interferência do CSS externo */
    .audio-embed{ 
      display:flex;
      align-items:center;
      gap:8px;
      width:100%;
      box-sizing:border-box;
      padding:8px 10px;
      cursor: pointer;
      overflow: visible; /* garante que avatar não seja cortado */
      user-select:none;
    }

    /* FORÇA esconder controles nativos / bibliotecas (caso Typebot injete algo) */
    .audio-embed audio,
    .audio-embed .plyr,
    .audio-embed input[type="range"],
    .audio-embed .native-player,
    .audio-embed .player-controls {
      display: none !important;
      visibility: hidden !important;
      height: 0 !important;
    }

    .play-btn{
      width:44px;
      height:44px;
      border-radius:50%;
      border:0;
      background:var(--primary);
      color:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      flex:0 0 44px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.08);
    }

    /* waveform estilo WhatsApp */
    .waveform{
      display:flex;
      align-items:flex-end;
      gap:4px;
      height:34px;
      flex:1 1 auto;
      min-width:60px;
      padding-right:6px;
      box-sizing:border-box;
      overflow: visible;
    }

    .bar{
      width:4px;
      height:8px;
      border-radius:3px;
      background:var(--bar-inactive);
      transition: height 0.08s linear, background 0.12s linear;
      transform-origin: center bottom;
    }

    /* avatar com microfone sobreposto (aproximado) */
    .avatar-wrap{
      position: relative;
      width:50px;
      height:50px;
      flex:0 0 50px;
      margin-left: -6px; /* aproxima a imagem da waveform */
      box-sizing:border-box;
      overflow: visible;
    }

    .avatar-wrap img{
      width:100%;
      height:100%;
      object-fit:cover;
      border-radius:50%;
      display:block;
      box-shadow: 0 1px 0 rgba(0,0,0,0.06);
    }

    .microphone-icon{
      position:absolute;
      right: -6px;    /* sobrepor levemente para ficar junto da imagem */
      bottom: -6px;
      font-size:18px;
      color:#4ad954;
      z-index:3;
      pointer-events:none; /* evita conflitos de clique */
      text-shadow: 0 1px 0 rgba(0,0,0,0.12);
    }
    .microphone-icon.blue{ color:#3db8ee; }

    /* pequeno ajuste responsivo */
    @media (max-width:360px){
      .waveform{ height:28px; gap:3px; }
      .bar{ width:3px; }
      .play-btn{ width:40px; height:40px; font-size:16px; }
      .avatar-wrap{ width:44px; height:44px; margin-left:-4px; }
      .microphone-icon{ right:-4px; bottom:-4px; font-size:16px; }
    }
  </style>
</head>
<body>
  <div class="audio-embed" id="audioEmbed">
    <button class="play-btn" id="playBtn" aria-label="Play/Pause">▶</button>

    <div class="waveform" id="waveform" aria-hidden="true"></div>

    <div class="avatar-wrap" id="avatarWrap">
      <!-- sua imagem (mantive sua URL) -->
      <img id="avatar" src="https://storage.chatecom.app/typebot/public/workspaces/gabrielpiochtavares@gmail.com/typebots/9af33e3d8b4d48209446784c81e9b566/blocks/cuae0wqlihuenlo77xtay29d?v=1726604919248" alt="Imagem">
      <div class="microphone-icon" id="micIcon"><i class="fas fa-microphone"></i></div>
    </div>

    <!-- seu áudio (mantive sua URL e crossorigin para Analyser funcionar quando permitido) -->
    <audio id="audio" crossorigin="anonymous"
      src="https://s3.typebot.io/public/workspaces/cmfid3w9w000qjr04ulcjbft9/typebots/b09hepl041fyv7q5nhf6dt39/blocks/uqehab3o02f69iybmix0wvrs?v=1757669692226"></audio>
  </div>

  <script>
    (function () {
      const audio = document.getElementById('audio');
      const playBtn = document.getElementById('playBtn');
      const waveform = document.getElementById('waveform');
      const micIcon = document.getElementById('micIcon');
      const audioEmbed = document.getElementById('audioEmbed');

      const NUM_BARS = 18;
      const MAX_BAR_HEIGHT = 34;
      const ACTIVE_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--bar-active').trim() || '#fff';
      const INACTIVE_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--bar-inactive').trim() || 'rgba(255,255,255,0.35)';

      // criar barras
      const bars = [];
      for (let i = 0; i < NUM_BARS; i++) {
        const b = document.createElement('div');
        b.classList.add('bar');
        // altura inicial aleatória (look natural)
        const initH = 6 + Math.round(Math.random() * (MAX_BAR_HEIGHT - 6));
        b.style.height = initH + 'px';
        b.style.background = INACTIVE_COLOR;
        waveform.appendChild(b);
        bars.push(b);
      }

      // esconder controles nativos (garantia extra)
      audio.controls = false;

      // Web Audio API
      let audioCtx = null, analyser = null, source = null;
      let dataArray = null, bufferLength = 0;
      let rafId = null;
      let analyserOk = false;
      let fallbackInterval = null;

      function initAnalyserIfPossible(){
        try {
          if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            source = audioCtx.createMediaElementSource(audio);
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            source.connect(analyser);
            analyser.connect(audioCtx.destination);
            analyserOk = true;
          }
        } catch (err) {
          analyserOk = false;
          console.warn('Analyser não disponível (CORS/navegador). Usando fallback.', err);
        }
      }

      function analyserLoop(){
        if (!analyser) return;
        analyser.getByteFrequencyData(dataArray);

        // mapear fatias do espectro para as barras
        for (let i = 0; i < NUM_BARS; i++) {
          const start = Math.floor(i * bufferLength / NUM_BARS);
          const end = Math.floor((i + 1) * bufferLength / NUM_BARS);
          let sum = 0;
          for (let j = start; j <= end; j++) sum += dataArray[j];
          const avg = sum / (end - start + 1);
          const h = Math.max(6, Math.round((avg / 255) * MAX_BAR_HEIGHT));
          bars[i].style.height = h + 'px';
        }

        // colorir parte tocada
        const prog = (audio.duration && !isNaN(audio.duration)) ? (audio.currentTime / audio.duration) : 0;
        const playedIndex = Math.floor(prog * NUM_BARS);
        bars.forEach((bar, idx) => {
          bar.style.background = (idx <= playedIndex) ? ACTIVE_COLOR : INACTIVE_COLOR;
        });

        rafId = requestAnimationFrame(analyserLoop);
      }

      function startFallback(){
        stopFallback();
        fallbackInterval = setInterval(() => {
          bars.forEach((b, i) => {
            const h = 6 + Math.round(Math.random() * (MAX_BAR_HEIGHT - 6));
            b.style.height = h + 'px';
          });
          // colorir por progresso
          const prog = (audio.duration && !isNaN(audio.duration)) ? (audio.currentTime / audio.duration) : 0;
          const playedIndex = Math.floor(prog * NUM_BARS);
          bars.forEach((bar, idx) => {
            bar.style.background = (idx <= playedIndex) ? ACTIVE_COLOR : INACTIVE_COLOR;
          });
        }, 110);
      }

      function stopFallback(){
        if (fallbackInterval) {
          clearInterval(fallbackInterval);
          fallbackInterval = null;
        }
      }

      function startVisuals(){
        micIcon.classList.add('blue');
        // tenta Web Audio
        initAnalyserIfPossible();
        if (analyserOk){
          cancelAnimationFrame(rafId);
          analyserLoop();
        } else {
          startFallback();
        }
      }

      function stopVisuals(){
        micIcon.classList.remove('blue');
        if (rafId) cancelAnimationFrame(rafId);
        stopFallback();
      }

      // play/pause handlers
      async function playAudio(){
        try {
          if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
          await audio.play();
          playBtn.textContent = '⏸';
          startVisuals();
        } catch(e){
          console.warn('Erro ao tocar áudio:', e);
        }
      }

      function pauseAudio(){
        audio.pause();
        playBtn.textContent = '▶';
        stopVisuals();
      }

      playBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        if (audio.paused) playAudio();
        else pauseAudio();
      });

      // clicar no container alterna (exceto quando clicando no botão)
      audioEmbed.addEventListener('click', (ev) => {
        if (ev.target === playBtn) return;
        if (audio.paused) playAudio();
        else pauseAudio();
      });

      // seek clicando na waveform (mapeia posição)
      waveform.addEventListener('click', (ev) => {
        if (!audio.duration || isNaN(audio.duration)) return;
        const rect = waveform.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const pct = Math.max(0, Math.min(1, x / rect.width));
        audio.currentTime = pct * audio.duration;
        // atualizar visual imediatamente
        const playedIndex = Math.floor(pct * NUM_BARS);
        bars.forEach((bar, idx) => {
          bar.style.background = (idx <= playedIndex) ? ACTIVE_COLOR : INACTIVE_COLOR;
        });
      });

      // eventos do audio
      audio.addEventListener('play', async () => {
        if (!audioCtx) initAnalyserIfPossible();
        if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
        startVisuals();
        playBtn.textContent = '⏸';
      });

      audio.addEventListener('pause', () => {
        playBtn.textContent = '▶';
        stopVisuals();
      });

      audio.addEventListener('ended', () => {
        playBtn.textContent = '▶';
        stopVisuals();
        // reset visual
        bars.forEach(b => {
          const h = 6 + Math.round(Math.random() * (MAX_BAR_HEIGHT - 6));
          b.style.height = h + 'px';
          b.style.background = INACTIVE_COLOR;
        });
      });

      // quando o áudio avança (ex.: seek), colorimos a parte tocada
      audio.addEventListener('timeupdate', () => {
        if (audio.duration && !isNaN(audio.duration)) {
          const prog = audio.currentTime / audio.duration;
          const playedIndex = Math.floor(prog * NUM_BARS);
          bars.forEach((bar, idx) => {
            bar.style.background = (idx <= playedIndex) ? ACTIVE_COLOR : INACTIVE_COLOR;
          });
        }
      });

      // proteção: se Analyser falhar, usa fallback
      window.addEventListener('unhandledrejection', () => { analyserOk = false; });

      // pronto — animações e interação configuradas
    })();
  </script>
</body>
</html>
